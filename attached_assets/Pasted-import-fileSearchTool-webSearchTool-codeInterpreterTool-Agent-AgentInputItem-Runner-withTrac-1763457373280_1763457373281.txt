import { fileSearchTool, webSearchTool, codeInterpreterTool, Agent, AgentInputItem, Runner, withTrace } from "@openai/agents";
import { z } from "zod";


// Tool definitions
const fileSearch = fileSearchTool([
  "vs_691b2685741881918f7ac84544d45cca"
])
const webSearchPreview = webSearchTool({
  searchContextSize: "medium",
  userLocation: {
    type: "approximate"
  }
})
const codeInterpreter = codeInterpreterTool({
  container: {
    type: "auto",
    file_ids: []
  }
})
const ClassifySchema = z.object({ operating_procedure: z.enum(["q-and-a", "fact-finding", "other"]) });
const classify = new Agent({
  name: "Classify",
  instructions: "Determine whether the question should use the Internal questions or fact-finding process. If the questions is about Spice World, It is directly an internal question process.",
  model: "gpt-4.1-nano",
  outputType: ClassifySchema,
  modelSettings: {
    temperature: 1,
    topP: 1,
    maxTokens: 2048,
    store: true
  }
});

const internalQA = new Agent({
  name: "Internal Q&A",
  instructions: "Answer the user's question using the knowledge tools you have on hand (file or web search). Be concise and answer succinctly, using bullet points and summarizing the answer up front",
  model: "gpt-4.1-nano",
  tools: [
    fileSearch
  ],
  modelSettings: {
    temperature: 1,
    topP: 1,
    maxTokens: 2048,
    store: true
  }
});

const externalFactFinding = new Agent({
  name: "External fact finding",
  instructions: `Explore external information using the tools you have (web search, file search, code interpreter). 
Analyze any relevant data, checking your work.

Make sure to output a concise answer followed by summarized bullet point of supporting evidence`,
  model: "gpt-5",
  tools: [
    webSearchPreview,
    codeInterpreter
  ],
  modelSettings: {
    reasoning: {
      effort: "low",
      summary: "auto"
    },
    store: true
  }
});

const agent = new Agent({
  name: "Agent",
  instructions: "Ask the user to provide more detail so you can help them by either answering their question or running data analysis relevant to their query",
  model: "gpt-4.1-nano",
  modelSettings: {
    temperature: 1,
    topP: 1,
    maxTokens: 2048,
    store: true
  }
});

type WorkflowInput = { input_as_text: string };


// Main code entrypoint
export const runWorkflow = async (workflow: WorkflowInput) => {
  return await withTrace("Ask Arden", async () => {
    const state = {

    };
    const conversationHistory: AgentInputItem[] = [
      { role: "user", content: [{ type: "input_text", text: workflow.input_as_text }] }
    ];
    const runner = new Runner({
      traceMetadata: {
        __trace_source__: "agent-builder",
        workflow_id: "wf_691aec679d148190acb697f21c1b97cf0f5d21d664dc03c5"
      }
    });
    const classifyResultTemp = await runner.run(
      classify,
      [
        ...conversationHistory,
        {
          role: "user",
          content: [
            { type: "input_text", text: `Question:  ${workflow.input_as_text}` }
          ]
        }
      ]
    );
    conversationHistory.push(...classifyResultTemp.newItems.map((item) => item.rawItem));

    if (!classifyResultTemp.finalOutput) {
        throw new Error("Agent result is undefined");
    }

    const classifyResult = {
      output_text: JSON.stringify(classifyResultTemp.finalOutput),
      output_parsed: classifyResultTemp.finalOutput
    };
    if (classifyResult.output_parsed.operating_procedure == "q-and-a") {
      const internalQAResultTemp = await runner.run(
        internalQA,
        [
          ...conversationHistory
        ]
      );
      conversationHistory.push(...internalQAResultTemp.newItems.map((item) => item.rawItem));

      if (!internalQAResultTemp.finalOutput) {
          throw new Error("Agent result is undefined");
      }

      const internalQAResult = {
        output_text: internalQAResultTemp.finalOutput ?? ""
      };
    } else if (classifyResult.output_parsed.operating_procedure == "fact-finding") {
      const externalFactFindingResultTemp = await runner.run(
        externalFactFinding,
        [
          ...conversationHistory
        ]
      );
      conversationHistory.push(...externalFactFindingResultTemp.newItems.map((item) => item.rawItem));

      if (!externalFactFindingResultTemp.finalOutput) {
          throw new Error("Agent result is undefined");
      }

      const externalFactFindingResult = {
        output_text: externalFactFindingResultTemp.finalOutput ?? ""
      };
    } else {
      const agentResultTemp = await runner.run(
        agent,
        [
          ...conversationHistory
        ]
      );
      conversationHistory.push(...agentResultTemp.newItems.map((item) => item.rawItem));

      if (!agentResultTemp.finalOutput) {
          throw new Error("Agent result is undefined");
      }

      const agentResult = {
        output_text: agentResultTemp.finalOutput ?? ""
      };
    }
  });
}
